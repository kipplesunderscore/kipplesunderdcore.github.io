<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Push Swap but actually Push Rotate | kipplesunderscore</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Push Swap is a 42 School Project where you must sort a list of numbers using 2 stacks and a limited set of operations.
You use 2 stacks A and B. The full list of unsorted numbers will input into A, then using the allowed operations you must sort the list into ascending order in stack A. Your algorithm needs to return the list of operations to perform to sort the list."><meta name=generator content="Hugo 0.103.1"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Push Swap but actually Push Rotate"><meta property="og:description" content="Push Swap is a 42 School Project where you must sort a list of numbers using 2 stacks and a limited set of operations.
You use 2 stacks A and B. The full list of unsorted numbers will input into A, then using the allowed operations you must sort the list into ascending order in stack A. Your algorithm needs to return the list of operations to perform to sort the list."><meta property="og:type" content="article"><meta property="og:url" content="https://kipplesunderscore.github.io/posts/push-swap/"><meta property="article:section" content="posts"><meta itemprop=name content="Push Swap but actually Push Rotate"><meta itemprop=description content="Push Swap is a 42 School Project where you must sort a list of numbers using 2 stacks and a limited set of operations.
You use 2 stacks A and B. The full list of unsorted numbers will input into A, then using the allowed operations you must sort the list into ascending order in stack A. Your algorithm needs to return the list of operations to perform to sort the list."><meta itemprop=wordCount content="1934"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Push Swap but actually Push Rotate"><meta name=twitter:description content="Push Swap is a 42 School Project where you must sort a list of numbers using 2 stacks and a limited set of operations.
You use 2 stacks A and B. The full list of unsorted numbers will input into A, then using the allowed operations you must sort the list into ascending order in stack A. Your algorithm needs to return the list of operations to perform to sort the list."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">kipplesunderscore</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Push Swap but actually Push Rotate</h1></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Push Swap is a 42 School Project where you must sort a list of numbers using 2 stacks and a limited set of operations.</p><p>You use 2 stacks A and B. The full list of unsorted numbers will input into A, then using the allowed operations you must sort the list into ascending order in stack A. Your algorithm needs to return the list of operations to perform to sort the list.</p><p>There are 4 types of operations that we can use:</p><ol><li><p>Push</p><ul><li><strong>pa</strong> pop from stack B and push onto stack A</li><li><strong>pb</strong> pop from stack A and push onto stack B</li></ul></li><li><p>Swap</p><ul><li><strong>sa</strong> swap first 2 elements on stack A</li><li><strong>sb</strong> swap first 2 elements on stack B</li><li><strong>ss</strong> both <strong>sa</strong> and <strong>sb</strong> at the same time</li></ul></li><li><p>Rotate</p><ul><li><strong>ra</strong> pop from stack A and insert at the end of stack A</li><li><strong>rb</strong> pop from stack B and insert at the end of stack B</li><li><strong>rr</strong> both <strong>ra</strong> and <strong>rb</strong> at the same time</li></ul></li><li><p>Reverse Rotate</p><ul><li><strong>rra</strong> pop from end stack A and push onto stack A</li><li><strong>rrb</strong> pop from end stack B and push onto stack B</li><li><strong>rrr</strong> both <strong>rra</strong> and <strong>rrb</strong> at the same time</li></ul></li></ol><p>Here is an example of what the input / output should look like:</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$&gt; ./push_swap 5 4 2 1 3
</span></span><span style=display:flex><span>pb
</span></span><span style=display:flex><span>rb
</span></span><span style=display:flex><span>pb
</span></span><span style=display:flex><span>sa
</span></span><span style=display:flex><span>pa
</span></span><span style=display:flex><span>ra
</span></span><span style=display:flex><span>pa
</span></span><span style=display:flex><span>ra</span></span></code></pre></div></div><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>Evaluation Criteria</h2><div id=outline-text-headline-1 class=outline-text-2><p>Your algorithm should be able to sort any list of non-duplicate, valid 32-bit signed integers and do so efficiently. There are requirements for number of operations for differing input size <strong>N</strong>. For this article I will focus on <strong>N</strong> = 500 (The largest tested input size) which has a requirement of less than 5500 operations for full score.</p></div></div><div id=outline-container-headline-2 class=outline-2><h2 id=headline-2>Solution</h2><div id=outline-text-headline-2 class=outline-text-2><p>I have implemented a solution to the problem below in Python we will take a look at some of the choices that can be made for parts of the algorithm and how it affects the operation count.</p><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Algorithm Overview</h3><div id=outline-text-headline-3 class=outline-text-3><p>The algorithm gets divided into 4 stages:</p><ol><li>Normalisation
Transform the numbers so that they are in the range 1 .. <strong>N</strong> (inclusive) while not strictly necessary, does help with debugging and some calculations like finding the smallest value.</li><li>AtoB
Perform <strong>pb</strong> operations until most of the numbers are in stack B.
At the end of this stack A should be in order.</li><li>BtoA
perform <strong>pa</strong> operations until all the numbers are back in stack A.
Note we can only perform the <strong>pa</strong> operation if stack A will remain in order.
This requires us to perform rotate operations on both stacks until we can <strong>pa</strong></li><li>Aligning A
find and move the smallest number to the top of the stack using rotate operations.</li></ol></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Game logic</h3><div id=outline-text-headline-4 class=outline-text-3><p>Here we have some functions to manage the state of the 2 stacks and record the list of operations. There are also some functions to help generate histogram plots used in this article.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib <span style=color:#66d9ef>as</span> mpl
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> bisect <span style=color:#f92672>import</span> bisect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>SA</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A[<span style=color:#ae81ff>0</span>],A[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> A[<span style=color:#ae81ff>1</span>],A[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;sa&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>PA</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>appendleft(B<span style=color:#f92672>.</span>popleft())
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;pa&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>PB</span>(A, B, OPS):
</span></span><span style=display:flex><span>    B<span style=color:#f92672>.</span>appendleft(A<span style=color:#f92672>.</span>popleft())
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;pb&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RA</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;ra&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RB</span>(A, B, OPS):
</span></span><span style=display:flex><span>    B<span style=color:#f92672>.</span>rotate(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;rb&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RR</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    B<span style=color:#f92672>.</span>rotate(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;rr&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RRA</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;rra&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RRB</span>(A, B, OPS):
</span></span><span style=display:flex><span>    B<span style=color:#f92672>.</span>rotate(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;rrb&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>RRR</span>(A, B, OPS):
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    B<span style=color:#f92672>.</span>rotate(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    OPS<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;rrr&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>random_list</span>(N):
</span></span><span style=display:flex><span>    lis <span style=color:#f92672>=</span> list(range(<span style=color:#ae81ff>1</span>, N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    random<span style=color:#f92672>.</span>shuffle(lis)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fig<span style=color:#f92672>=</span>plt<span style=color:#f92672>.</span>figure()
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>rcParams[<span style=color:#e6db74>&#34;hist.bins&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>plot_algo</span>(algo):
</span></span><span style=display:flex><span>    fig<span style=color:#f92672>.</span>clear(<span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>hist(push_swap(<span style=color:#ae81ff>100</span>))
</span></span><span style=display:flex><span>    fig<span style=color:#f92672>.</span>tight_layout()
</span></span><span style=display:flex><span>    fname <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>algo<span style=color:#e6db74>}</span><span style=color:#e6db74>.png&#39;</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>savefig(fname)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>push_swap</span>(simulations):
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(simulations):
</span></span><span style=display:flex><span>        OPS <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        A <span style=color:#f92672>=</span> deque(random_list(<span style=color:#ae81ff>500</span>))
</span></span><span style=display:flex><span>        B <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>        atob(A, B, OPS)
</span></span><span style=display:flex><span>        btoa(A, B, OPS)
</span></span><span style=display:flex><span>        align_a(A, B, OPS)
</span></span><span style=display:flex><span>        data<span style=color:#f92672>.</span>append(len(OPS))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> data</span></span></code></pre></div></div></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>BtoA</h3><div id=outline-text-headline-5 class=outline-text-3><p>This stage involves finding the element in stack B that represents the cheapest set of rotate operations, such that we can perform a <strong>pa</strong> operation.</p><div id=outline-container-headline-6 class=outline-4><h4 id=headline-6>Find target index in stack A</h4><div id=outline-text-headline-6 class=outline-text-4><p>For each candidate in stack B we compute it's target index. The target index value is the index in stack A where the candidate needs to go to keep stack A in order.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># function to find the index at which `e`</span>
</span></span><span style=display:flex><span><span style=color:#75715e># will need to insert into in order to keep</span>
</span></span><span style=display:flex><span><span style=color:#75715e># A in order.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>target_index</span>(A, e):
</span></span><span style=display:flex><span>    <span style=color:#75715e># move the smallest number to the top of the stack</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># note this does not update our outputted instructions</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>index(min(A))
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(<span style=color:#f92672>-</span>i)
</span></span><span style=display:flex><span>    <span style=color:#75715e># bisect is a python built-in that finds the required index</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># as long as the given list is sorted</span>
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=</span> (bisect(A, e) <span style=color:#f92672>+</span> i) <span style=color:#f92672>%</span> len(A)
</span></span><span style=display:flex><span>    <span style=color:#75715e># undo the rotation from earlier</span>
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>rotate(i)
</span></span><span style=display:flex><span>    <span style=color:#75715e># determine if it would be better to rotate vs reverse rotate</span>
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=</span> target <span style=color:#66d9ef>if</span> target <span style=color:#f92672>&lt;=</span> (len(A) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span>(len(A) <span style=color:#f92672>-</span> target)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> target</span></span></code></pre></div></div></div></div><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>Find cheapest candidate</h4><div id=outline-text-headline-7 class=outline-text-4><p>Here we use our target_index function to find the candidate in stack B that has the cheapest cost. For each candidate we need to calculate the cost of rotating the candidate to the top of stack B and the cost to rotate stack A into position.
We also need to keep in mind when we can perform the double rotate operations (<strong>rr</strong> and <strong>rrr</strong>) as they will affect the costs. we do this by considering the sign of the cost negative costs being reverse rotates.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>op_cost</span>(a, b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> a <span style=color:#f92672>*</span> b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># we can rotate both stacks a the same time</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(abs(a), abs(b))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># stacks want to rotate different directions</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> abs(a) <span style=color:#f92672>+</span> abs(b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_cheapest</span>(A, B):
</span></span><span style=display:flex><span>    <span style=color:#75715e># set cheap to most expensive operation</span>
</span></span><span style=display:flex><span>    cheap <span style=color:#f92672>=</span> (<span style=color:#f92672>-</span>len(A), len(B))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(B)):
</span></span><span style=display:flex><span>        <span style=color:#75715e># if this is true the cost to rotate just B is more expensive</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># than our cheapest so we are done</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> op_cost(i, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&gt;=</span> op_cost(<span style=color:#f92672>*</span>cheap):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># check cost if we rotate</span>
</span></span><span style=display:flex><span>        tmp <span style=color:#f92672>=</span> (target_index(A, B[i]), i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> op_cost(<span style=color:#f92672>*</span>tmp) <span style=color:#f92672>&lt;</span> op_cost(<span style=color:#f92672>*</span>cheap):
</span></span><span style=display:flex><span>            cheap <span style=color:#f92672>=</span> tmp
</span></span><span style=display:flex><span>        <span style=color:#75715e># check cost  if we reverse rotate</span>
</span></span><span style=display:flex><span>        tmp <span style=color:#f92672>=</span> (target_index(A, B[<span style=color:#f92672>-</span>i]), <span style=color:#f92672>-</span>i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> op_cost(<span style=color:#f92672>*</span>tmp) <span style=color:#f92672>&lt;</span> op_cost(<span style=color:#f92672>*</span>cheap):
</span></span><span style=display:flex><span>            cheap <span style=color:#f92672>=</span> tmp
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cheap</span></span></code></pre></div></div></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>Performing the operations</h4><div id=outline-text-headline-8 class=outline-text-4><p>Now that we can calculate the cheapest cost to insert a candidate from B into A. we need to execute a series of rotate operations before finally doing a <strong>pa</strong> operation.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>btoa</span>(A, B, OPS):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (len(B) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># get the cheapest cost to insert an candidate into stack A</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># positive costs are rotates while negative are reverse rotates</span>
</span></span><span style=display:flex><span>        cost_a, cost_b <span style=color:#f92672>=</span> find_cheapest(A, B)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cost_a <span style=color:#f92672>*</span> cost_b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># stacks want to rotate in the same direction</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># tmp contains the number of rotations to perform</span>
</span></span><span style=display:flex><span>            tmp <span style=color:#f92672>=</span> min(cost_a, cost_b) <span style=color:#66d9ef>if</span> cost_a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> max(cost_a, cost_b)
</span></span><span style=display:flex><span>            <span style=color:#75715e># do the rotations on both stacks</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(abs(tmp)):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> cost_a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                    RR(A, B, OPS)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    RRR(A, B, OPS)
</span></span><span style=display:flex><span>            <span style=color:#75715e># make sure to adjust costs in case of leftover rotations</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># one of these costs should be zero at this point</span>
</span></span><span style=display:flex><span>            cost_a <span style=color:#f92672>-=</span> tmp
</span></span><span style=display:flex><span>            cost_b <span style=color:#f92672>-=</span> tmp
</span></span><span style=display:flex><span>        <span style=color:#75715e># rotate stack A</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(abs(cost_a)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cost_a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                RA(A, B, OPS)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                RRA(A, B, OPS)
</span></span><span style=display:flex><span>        <span style=color:#75715e># rotate stack B</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(abs(cost_b)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cost_b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                RB(A, B, OPS)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                RRB(A, B, OPS)
</span></span><span style=display:flex><span>        <span style=color:#75715e># push number B to A</span>
</span></span><span style=display:flex><span>        PA(A, B, OPS)</span></span></code></pre></div></div></div></div></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>Aligning A</h3><div id=outline-text-headline-9 class=outline-text-3><p>This is a straightforward calculation we find the index of the smallest value in stack A and then perform rotate operations to bring it to the top of the stack.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>align_a</span>(A, B, OPS):
</span></span><span style=display:flex><span>    <span style=color:#75715e># find index of smallest value in list</span>
</span></span><span style=display:flex><span>    small <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>index(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># determine if we rotate or reverse rotate</span>
</span></span><span style=display:flex><span>    small <span style=color:#f92672>=</span> small <span style=color:#66d9ef>if</span> small <span style=color:#f92672>&lt;=</span> len(A) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span>(len(A) <span style=color:#f92672>-</span> small)
</span></span><span style=display:flex><span>    <span style=color:#75715e># rotate smallest value to top of stack</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(abs(small)):
</span></span><span style=display:flex><span>        RA(A, B, OPS) <span style=color:#66d9ef>if</span> small <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> RRA(A, B, OPS)</span></span></code></pre></div></div></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>AtoB</h3><div id=outline-text-headline-10 class=outline-text-3><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>Need sa?</h4><div id=outline-text-headline-11 class=outline-text-4><p>When there are 3 elements in stack A we can at worst perform 1 <strong>sa</strong> operation to put the elements in order.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>need_sa</span>(A, B):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(A) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    max_val <span style=color:#f92672>=</span> max(A)
</span></span><span style=display:flex><span>    min_val <span style=color:#f92672>=</span> min(A)
</span></span><span style=display:flex><span>    <span style=color:#75715e># essentially just checks to see if the number after the max value</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># is not the min value if it is not then we need to swap A</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((A[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> max_val <span style=color:#f92672>and</span> A[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> min_val) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>            (A[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> max_val <span style=color:#f92672>and</span> A[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> min_val) <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>            (A[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> max_val <span style=color:#f92672>and</span> A[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>!=</span> min_val))</span></span></code></pre></div></div></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>AtoB Algorithm Options</h4><div id=outline-text-headline-12 class=outline-text-4><p>At this point the above algorithm for BtoA is set. The last decision we need to make is how we push elements from AtoB. This is where I found a lot of the variance in the number of operations.</p><div id=outline-container-headline-13 class=outline-5><h5 id=headline-13>Keep 3</h5><div id=outline-text-headline-13 class=outline-text-5><p>Seeing as how we have the need_sa function the first thing we should try is just blindly pushing all but 3 elements into stack B. Then check if we need to perform a <strong>sa</strong></p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>atob</span>(A, B, OPS):
</span></span><span style=display:flex><span>    <span style=color:#75715e># push all but 3 values from A to B</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(A) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>        PB(A, B, OPS)
</span></span><span style=display:flex><span>    <span style=color:#75715e># check to see if we need to swap A to put the 3 values in order</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> need_sa(A, B):
</span></span><span style=display:flex><span>        SA(A, B, OPS)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plot_algo(<span style=color:#e6db74>&#34;keep3&#34;</span>)</span></span></code></pre></div></div><p>As we can see from the results this does a pretty good job and goes to show the power of the BtoA algorithm. There are some outliers above the 5500 limit however. This will give us a pass for this project but there is one minor change we can make to this algorithm to get us full marks.</p><p><img src=keep3.png alt=keep3.png title=keep3.png></p></div></div><div id=outline-container-headline-14 class=outline-5><h5 id=headline-14>Keep 3 Rotate Under</h5><div id=outline-text-headline-14 class=outline-text-5><p>This algorithm is basically the same as above, the only difference is that after we push an element onto stack B. We determine if this element is in the larger half (i.e. e > 250 for N = 500) if it is we do a <strong>rb</strong> operation. This will move all the large numbers to the bottom of stack B. At the end of the AtoB operation, stack B will have all the small numbers in the top half followed by all the large numbers.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>atob</span>(A, B, OPS):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(A) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>        PB(A, B, OPS)
</span></span><span style=display:flex><span>        <span style=color:#75715e># if the value just pushed is a large number move it to</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># the bottom of stack B with a `rb`</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> B[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> n <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>            RB(A, B, OPS)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> need_sa(A, B):
</span></span><span style=display:flex><span>        SA(A, B, OPS)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plot_algo(<span style=color:#e6db74>&#34;keep3_rotate&#34;</span>)</span></span></code></pre></div></div><p>As we can see from the histogram we are easily under 5000 operations now and have acquired full marks for this project.</p><p><img src=keep3_rotate.png alt=keep3_rotate.png title=keep3_rotate.png></p></div></div><div id=outline-container-headline-15 class=outline-5><h5 id=headline-15>Can we do better</h5><div id=outline-text-headline-15 class=outline-text-5><p>Below is my final submission, it involves splitting the values into more chunks, the previous algorithm split the numbers into 2 chunks this one splits into 6 which saves more operations. The reason why this chunk splitting is so effective is that by keeping numbers of similar ranges together you lower the average costs for the BtoA algorithm.</p><div class="src src-python"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>CHUNKS <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.7</span>, <span style=color:#ae81ff>0.85</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>atob_push</span>(A, B, OPS, lo, hi):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>    large_threshold <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> ((hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(A) <span style=color:#f92672>&gt;</span> n <span style=color:#f92672>-</span> (hi <span style=color:#f92672>-</span> lo):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> lo <span style=color:#f92672>&lt;</span> A[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> hi:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> need_rb:
</span></span><span style=display:flex><span>                RB(A, B, OPS)
</span></span><span style=display:flex><span>                need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>            PB(A, B, OPS)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> B[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> large_threshold:
</span></span><span style=display:flex><span>                need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            RR(A,B, OPS) <span style=color:#66d9ef>if</span> need_rb <span style=color:#66d9ef>else</span> RA(A, B, OPS)
</span></span><span style=display:flex><span>            need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>atob</span>(A, B, OPS):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(A)
</span></span><span style=display:flex><span>    prev_hi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>20</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> CHUNKS:
</span></span><span style=display:flex><span>            hi <span style=color:#f92672>=</span> int(n <span style=color:#f92672>*</span> i)
</span></span><span style=display:flex><span>            lo <span style=color:#f92672>=</span> prev_hi
</span></span><span style=display:flex><span>            atob_push(A, B, OPS, lo, hi)
</span></span><span style=display:flex><span>            prev_hi <span style=color:#f92672>=</span> hi
</span></span><span style=display:flex><span>    large_threshold <span style=color:#f92672>=</span> prev_hi <span style=color:#f92672>+</span> ((n <span style=color:#f92672>-</span> prev_hi) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(A) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> need_rb:
</span></span><span style=display:flex><span>            RB(A, B, OPS)
</span></span><span style=display:flex><span>            need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        PB(A, B, OPS)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> B[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> large_threshold:
</span></span><span style=display:flex><span>            need_rb <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> need_sa(A, B):
</span></span><span style=display:flex><span>        SA(A, B, OPS)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plot_algo(<span style=color:#e6db74>&#34;final&#34;</span>)</span></span></code></pre></div></div><p><img src=final.png alt=final.png title=final.png></p></div></div></div></div></div></div></div></div><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://kipplesunderscore.github.io/>&copy; kipplesunderscore 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>